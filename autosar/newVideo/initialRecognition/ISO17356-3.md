
## 介绍



汽车应用的特点是具有严格的实时要求。因此，操作系统(0S)提供了必要的功能来支持事件驱动(event driven)的控制系统。

指定的操作系统服务是实现各厂商软件模块集成的基础。为了能够对单个控制单元的特定特性做出反应，而决定于它们的性能和对资源的最低消耗需求，主要的重点不是实现应用程序模块之间的100%兼容性，而是它们的直接可移植性。

由于操作系统旨在用于任何类型的控制单元，它支持在广泛的硬件上的时间关键(time critical)应用程序。高度的模块化和灵活配置的能力是使操作系统适合低端微处理器和复杂控制单元的先决条件。这些需求已经被“一致性类”定义(见 3.2)和特定于应用程序的适应的特定能力所支持。

对于时间紧迫的应用程序，系统对象的动态生成被丢弃了 。(**动态生成就是类似malloc又不确定性**)。相反，系统对象的生成被分配给系统生成阶段。操作系统内的错误查询可以在很大程度上避免，从而不会不必要地影响整个系统的速度。(**在实际应用中可以把一些没用的错误查询关掉,DET**)另一方面，定义了具有扩展错误查询的系统版本。它适用于测试阶段和时间要求较低的应用程序。即使在这个阶段，也确保了定义(**api**)的统一系统外观(**api是确定的，就是打开扩展错误查询和不打开扩展错误查询的代码是一样的，不需要重新写**)。

## 0.1.1标准接口
应用软件与操作系统之间的接口由系统服务(system service)定义。对于各种处理器家族上的操作系统的所有实现，接口是相同的。

系统服务指定为ISO/ANSI-C类语法(也就是说API是C定义的)，但是没有指定系统服务的实现语言。

## 0.1.2 可伸缩性
不同的一致性类(**不同的配置等级**)、各种调度机制和配置特性使操作系统适用于广泛的应用程序和硬件。该操作系统被设计为只需要最少的硬件资源(RAM、ROM、CPU 时间)，因此甚至可以在8 位微控制器上运行。

## 0.1.3 错误检查
OS提供了两个级别的错误检查，开发阶段的扩展状态和生产阶段的标准状态。

扩展状态允许对调用OS服务进行增强的合理性检查。由于附加的错误检查，它比标准版本需要更多的执行时间和内存空间。然而，在测试阶段可以发现许多错误。在消除了所有错误之后，可以使用标准版本重新编译系统。

## 0.1.4 应用程序移植
ISO 17356 的目标之一是支持应用软件的可移植性和可重用性。因此，应用程序软件和操作系统之间的接口由具有定义良好的功能的标准化系统服务定义。使用标准化的系统服务可以减少维护和移植应用程序软件的工作量和开发成本。

api例子：
![20250109190257](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250109190257.png)

可移植性意味着能够将一个应用软件模块从一个 ECU 转移到另一个 ECU,而无需对应用程序内部进行更大的更改。操作系统的标准化接口(服务调用、类型定义和常量)支持源代码级别的可移植性。目标代码(obiect code)的交换不是 ISO 17356 规定的。

应用程序软件部署在操作系统上，与应用程序特定的IO系统接口是 parallel的，这些 IO接口在 IS0 17356 中没有标准化。应用软件模块可以有多个接口。有用于实时控制和资源管理的操作系统接口，但也有用于表示系统中完整功能的其他软件模块的接口，如果应用程序直接工作在微控制器上，至少也有用于硬件的接口。

![20250109190740](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250109190740.png)

**注意:OSEK OS 允许应用程序通过 API 直接操作硬件，即图中IO system 部分。**
在将应用软件从一个 ECU 移植到另一个 ECU 的过程中，必须考虑软件开发过程的特点、ECU 的开发环境和硬件架构，例如:
--软件开发指导方针;
--文件管理系统;
--编译器的数据分配和栈使用;
--ECU 的内存结构(memory architecture);
--ECU 的时序行为(timing behaviour);
--不同的单片机专用接口，如端口、A/D 转换器、串行通信和看门狗定时器;
--API调用的设计
这意味着规范不足以完全描述实现。实现应该提供特定的文档。(**每家os实现时特殊需要提供自己的说明文档，就类似c语言大致规范是有的，不同的编译器细节有差异**)

## 0.1.5 移植的支持
认证过程确保了不同实现与规范的一致性。本标准第 14 条收集实现的具体细节，这些细节应被视为提高应用程序在不同实现之间的可移植性。这里只考虑应用程序的操作系统接口。(**没有考虑IO实现的移植**)

## 0.1.6车规级需求的特殊文持
对操作系统的特定要求在汽车控制单元软件开发中不断增加。以下特性满足可靠性、实时性和成本敏感性等需求:

--操作系统静态配置和扩展。用户静态地指定所需的任务、资源和服务的数量。
--操作系统规范支持能够在 ROM 上运行的实现，即代码可以从只读内存中执行。
--操作系统支持应用任务的可移植性。
--操作系统规范提供了一个可预测的(**就是对任务执行时间有预测性能计算出来的，最坏情况下的执行时间，比如刹车要求20ms必须响应**)和文档化的行为,使操作系统实现能够满足汽车实时需求。
--操作系统的规范允许实现可预测的性能参数。(**静态就是可预测的，动态就是不可预测的****)

## 0.2 本文档目标
下面的描述被认为是一个通用的描述，对于任何操作系统的实现都是强制性的。这涉及策略和功能的一般描述、调用的接口、参数的含义和声明以及可能的错误代码。

IS0 17356 的这一部分保留了一定的灵活性。一方面，该描述足够通用，适合未来的升级;另一方面，部分描述是显式指定并且是“具体实现相关”的。

任何实现都定义了所有“具体实现相关”的事项。实现支持的一致性类(**四种级别**)被精确地指出。并且特定于实现的问题被记录下来。(**对于每一种情况具体实现是准确的**)

因为这种描述是强制性的,所以只在涉及一般系统策略时才进行定义。在所有其他方面,由系统实现决定对特定硬件类型的最佳适配。

## 0.3 本文档结构
### 0.3.1 General
简要介绍本标准的各条款：
### 0.3.2 第3 条-操作系统“os”的架构
本章主要介绍操作系统的设计原则和体系结构。
### 0.3.3 第4条-任务管理
本节解释使用不同任务类型和调度机制的任务管理，
### 0.3.4第5条-应用模式
本节描述应用程序模式以及如何支持它们。
### 0.3.5 第6条-中断处理
### 0.3.6第7条-事件机制
本章解释了事件机制和不同调度的不同行为。
### 0.3.7 第8条-资源管理
本章描述了资源管理，并讨论了优先级天花板机制的好处和实现。
### 0.3.8第9条-Alarm
本节描述了两个阶段的概念，以支持基于时间的事件(如硬件定时器)和非基于时间的事件

### 0.3.9 第 10 条-消息
IS0 17356-3 增加了处理器内部通信的消息处理。IS0 17356-4描述了完整的消息处理要实现的确切子集在 ISO 17356-4 中有描述。
### 0.3.10 第 11 条-错误处理、跟踪和调试
本节描述实现集中错误处理的机制。它还描述了用于初始化和关闭系统的服务。
### 0.3.11 第 12 条-系统服务的描述
描述时使用的约定。
### 0.3.12第13条b作系统服务的规范
本条款描述了用户可以使用的所有操作系统服务。描述的结构对于任何服务都是相同的,它包含用户需要的有关于 service 的所有信息。
### 0.3.13 第 14 条-具体实现相关和特定应用相关的话题
本章讲述所有特定于操作系统的话题，如服务、数据类型和常量。

## 0.4 总结
### 0.4.1 General
操作系统提供了一个不同服务(**api**)和处理机制(**同步异步**)的池。它是根据用户在系统生成时的配置指令构建的。

描述了四个一致性类，旨在满足关于操作系统功能和能力的不同需求。这样，用户就可以根据控制任务和目标硬件来调整操作系统。**操作系统不可在运行时被动态修改。**

为某个一致性类编写的应用程序可以移植到同一个类的实现。这是由服务的定义、它们的功能范围和每个一致性类的行为来确保的。只有当一个一致性类的所有服务都以确定的能力范围提供时，操作系统实现才符合IS0 17356-3。服务组是按照功能来组织的。

### 0.4.2 任务管理
任务管理包括:
--任务的激活和终止:
--任务状态管理和任务切换管理。

### 0.4.3 同步
操作系统支持以下方式使同步生效:
--资源管理;
--对共同使用的(逻辑)资源或设备的不可分割的操作的访问控制,或对程序流的控制;
--事件控制:
--任务同步的事件管理。
### 0.4.4 中断管理
这包括中断处理服务。
### 0.4.5 Alarm
可以是相对的，也可以是绝对的。Alarny
### 0.4.6 处理器内消息处理
这包括用于数据交换的服务。
### 0.4.7 错误处理
这包括在出现各种错误时支持用户的机制。


## 1范围
OSEK/VDX 是汽车行业的一个联合项目。它旨在为汽车分布式控制单元提供一个开放式架构的行业标准。
IS0 17356 的这一部分描述了能够多任务处理的实时操作系统的概念,可用于机动车辆。它不是与特定实现相关的产品描述。它还指定操作系统应用程序接口(Application ProgramInterface, APl).
通用惯例、术语解释和缩写已在 IS0 17356-1中包括。IS0 17356-6描述了实现和系统生成方面的内容。
该操作系统规范为汽车控制单元应用软件提供了一个支持资源高效利用的统一环境。该操作系统是用于分布式嵌入式控制单元的**单处理器操作系统**。

## 2 引用标准
以下参考文件是本文档应用中不可缺少的参考文件。对于标注日期的参考文献，只有引用的版本适用。对于未注明日期的引用，引用文件的最新版本(包括任何修订)适用。

IS0 17356-1，道路车辆。嵌入式汽车应用的开放接口。第1部分:一般结构和术语、定义和缩写术语
IS0 17356-2，道路车辆。嵌入式汽车应用的开放接口。第2部分:绑定 OS:COM 和NM的 OSEK/VDX 规范
IS0 17356-6,道路车辆。嵌入式电子设备的开放接口。第6部分:OSEK/DX 实现语言(OIL)。

## 3 OS的架构
### 3.1 处理等级
操作系统是相互独立的多个应用程序运行的基础,并在处理器上提供应用程序运行环境。
该操作系统能够控制多个并行运行的进程的实时执行。

操作系统为用户提供了一组定义好的接口。这些接口由竞争 CPU的 entities 使用。Entities有两种类型:
--由操作系统管理的中断服务程序；
--任务(基本任务和扩展任务)。
控制单元的硬件资源可以由操作系统服务管理。这些操作系统服务由统一的接口调用要么由应用程序调用，要么在操作系统内部调用。
操作系统定义了三个处理级别:
--中断级;
--调度程序的逻辑级;
--任务级。
在任务级别内，任务根据用户分配的优先级进行调度(非优先级、全优先级或混合优先级)。运行时上下文在任务执行开始时被占用，并在任务完成后再次被释放。
![20250113184317](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250113184317.png)

制定了下列优先级规则:
--中断优先于任务。
--中断处理级别由一个或多个中断优先级组成。
--中断服务例程有一个静态分配的中断优先级。
--中断服务程序分配到中断优先级取决于具体实现和硬件架构。
--对于任务优先级和资源天花板优先级(**解决优先级反转**)，数字越大表示优先级越高。
--任务的优先级由用户静态分配。(任务优先级的含义见4.5。)
用于处理 task 和 ISR 的处理 level 定义为一系列连续的值。操作系统优先级到硬件优先级的映射是特定于实现的。

说明:为调度程序分配优先级只是一个逻辑概念，甚至可以在不直接使用优先级的情况下实现。此外，它没有规定任务优先级和特定微处理器体系结构相关的硬件中断level的任何规则。

### 3.2 一致性类
应用软件对系统的各种需求和特定系统的各种能力(如处理器、内存)要求操作系统具有不同的功能。在下面的描述中，这些操作系统特性被描述为“一致性类“(CC)。

一致性类的存在是为了支持以下目标:

--提供方便的操作系统功能组，以便更容易理解和讨论操作系统;

--允许部分实现(可能被认证为兼容的)沿着预定义的路线;

--创建从功能较低的类到功能较高的类的升级路径,而不使用相关特性更改应用程序。

要获得认证，应实现完整的一致性等级。然而，系统生成只需要链接特定应用程序所需的那些系统服务。在运行时无法更改一致性等级(也就是说必须配置时确定)。

一致性类由以下属性决定:

--任务激活的多个请求，如4.3 所述;

--任务类型，如 4.2.4 所述;

--每个优先级的任务数。

如果没有明确说明，所有其他功能都是强制性的。

![20250114085514](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114085514.png)

定义了以下一致性类:

--BCC1(只有基本任务，每个任务一个激活请求，每个优先级一个任务，而所有任务有不
同的优先级);

--BCC2(类似于 BCC1，但是每个优先级支持一个以上的任务，允许多个任务激活请求);

--ECC1(类似于 BCC1，加上扩展任务);

--ECC2(与ECC1类似，但是每个优先级支持多个任务，并且允许基本任务有多个任务激活请求)。

只有在不超过最低要求的情况下，才能假定应用程序的可移植性。一致性类的最低要求显示在表1中。
![20250114085932](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114085932.png)

### 3.3 0s 和 OSEKtime os 的关系

OSEKtime os (www.osek-vdx.org)是一个特别适合时间触发架构需求的操作系统。它允许IS0 17356-3与 OSEKtim手操作系统共存。从概念上讲，OSEKtime 分配它的 idle time 给 ISO17356-3 的 task。OSEKOS 的中断和任务的重要性低于(表现为优先级低)OSEKtime os 中类似的 entities.

如果 OSEK OS与OSEKtime共存,OSEK OS接口和系统调用的定义不会改变。由于OSEKtime负责整个系统，而OS只负责本地，所以在系统启动和关闭方面有一些小的例外。这些偏差在ISO 17356的这一部分中特别提到。

在此之上，在 OSEKtime 中定义的功能对 OSEKOS 的实现施加了限制J如果 OSEKOS 打算与 OSEKtime操作系统共存的话。如需更多信息，请参阅说明书OSEKtime 操作系统。

## 4 任务管理
### 4.1 任务概念
#### 4.1.1 General
复杂的控制软件可以方便地按实时性要求划分为不同的执行部分。这些部分应通过任务来实现。任务为函数们的执行提供了框架。操作系统提供任务的并发和异步执行。调度程序组织任务执行的顺序。
操作系统提供了一种任务切换机制(参见scheduler,4.4)，包括一种在没有其他系统或应用程序功能处于活动状态时处于活动状态的机制。这种机制称为空闲机制。操作系统提供了两种不同的任务概念:

--基本任务;

--扩展任务。

#### 4.1.2 基本任务
基本任务只有在以下情况下才会释放处理器:
--他们终止;
--操作系统切换到更高优先级的任务;
--或一个中断发生，导致处理器切换到一个中断服务程序(ISR)。

#### 4.1.3 扩展任务
扩展任务与基本任务的区别在于允许使用Os WaitEvent,这可能会导致等待状态(参见第7章和13.6.3.4节)。等待状态允许释放处理器并将其重新分配给低优先级的任务，而不需要终止正在运行的扩展任务。

从操作系统的角度来看，扩展任务的管理在原则上比基础任务的管理更加复杂，需要更多的系统资源。

### 4.2 任务状态模型
#### 4.2.1 General
下面的文本描述了这两种任务类型的任务状态和状态之间的转换。

一个任务应该能够在多个状态之间变化,因为处理器在任何时候只能执行一个任务的一条指令，而多个任务可能在同一时间竞争处理器。操作系统负责在必要时连同任务状态转换起保存和恢复任务上下文。

#### 4.2.2 扩展任务
扩展任务有四种任务状态:

--运行:在运行状态下，任务被分配给CPU，使其指令可以执行。在任何时间点，只有一个任务处于该状态，而其他所有状态可以被多个任务同时采用。

--就绪:转换到运行状态的所有功能先决条件都已经存在，任务只等待处理器的分配。
调度程序决定接下来执行哪个准备好的任务。

--等待:任务不能继续执行，因为它必须等待至少一个事件(见章节7)。

--挂起:任务为被动状态，可被激活。

![20250114091244](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114091244.png)

![20250114092626](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114092626.png)

只有当任务自己终止(“self-terminate")时，才有可能终止任务。这个限制降低了操作系统的复杂性。不提供从挂起状态到等待状态的直接转换。这种转换是多余的，会增加调度器的复杂性。

#### 4.2.3 基本任务
基本任务的状态模型几乎与扩展任务的状态模型相同。唯一的例外是基本任务没有等待状态。基本任务由以下任务状态组成:

--运行:在运行状态下，任务被分配给 CPU，使其指令可以执行。在任何时间点，只有一个任务处于该状态，而其他所有状态可以被多个任务同时采用。

--就绪:转换到运行状态的所有功能先决条件都已经存在，任务只等待处理器的分配调度程序决定接下来执行哪个准备好的任务。

--挂起:任务为被动状态，可被激活。

![20250114100316](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114100316.png)

![20250114100333](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114100333.png)

#### 4.2.4 任务类型的比较

基本任务没有等待状态，因此只包含任务开始和结束的同步点。具有内部同步点的application parts(**每一个函数是一个parts**)应由多个基本任务实现。基本任务的一个优点是它们对运行时上下文(RAM)的需求适中。

扩展任务的一个优点是，无论哪个同步请求是活动的，它们都可以在单个任务中处理一致的作业。当需要进一步处理的当前信息缺失时，扩展任务将切换到等待状态。当相应的事件发出接收或更新所需数据或事件的信号时，它将退出此状态。扩展任务还包含比基本任务更多的同步点。

### 4.3 激活一个任务
#### 4.3.1 General
任务激活通过操作系统服务 ActivatTask或chainTask进行。激活后，任务就可以从第一条语句开始执行了。

操作系统在启动任务时不支持类c参数传递。这些参数应该通过消息通信(参见第10条)或全局变量传递。

#### 4.3.2 任务激活的多个请求
根据一致性类的不同，基本任务可以被激活一次或多次。"任务激活的多个请求"意味着操作系统接收并记录一个已激活的基本任务的并行激活。(**判断任务会不会被多次激活就看是否会计数**)
并行多个请求的数量在系统生成期间在一个基本任务特定属性中定义。如果未达到多个请求的最大数量，则请求将进入队列。基本任务激活的请求按激活顺序按优先级排队。

## 4.4 任务切换机制

与传统的顺序编程不同，多任务处理原则上允许操作系统并发地执行各种任务。因此，需要明确调度策略(参见 4.6)。

决定启动哪个任务和触发所有必要的操作系统内部活动的实体被称为“调度程序”。根据所述的调度策略，只要有可能进行任务切换，就激活所述调度程序。调度器可以被看作是一种可以被任务占用和释放的资源。因此，任务可以保留调度程序，以避免任务切换，直到它被释放(见 8.4)。

## 4.5 任务优先级
调度程序根据任务优先级来决定哪个任务是下一个要转移到运行态的就绪任务。

0被定义为任务的最低优先级。因此，数字越大，优先级越高。

为提高效率，不支持动态优先级管理。因此，任务的优先级是静态定义的，即用户在运行时不能更改任务的优先级。但是，在特定情况下，OS可以处理具有定义的更高优先级的任务(**天花板级**)(参见 8.6)。

一致性类BCC2和ECC支持具有相同优先级的任务(参见3.2)。

具有相同优先级的任务根据其激活顺序启动,处于等待状态的扩展任务不会阻塞具有相同优先级的后续任务的启动。

被抢占的任务被认为是其当前优先级的就绪列表中的第一个(最早的)任务。
从等待状态释放的任务将被视为其优先级就绪队列中的最后一个(最新的)任务。

图6显示了使用每个优先级级别的队列实现调度程序的示例。几个优先级不同的任务处于就绪状态;即三个优先级为3的任务，一个优先级为2，一个优先级为1，再加上两个优先级为0的任务。根据请求的顺序，等待时间最长的任务显示在每个队列的底部。处理器刚刚处理并终止了一个任务。调度程序选择要处理的下一个任务(优先级3，第一个队列)。在处理优先级2的任务之前，所有高优先级的任务都必须处于运行就绪状态，即启动，然后由于终止或过渡到等待状态而从队列中移除。

![20250114102934](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114102934.png)

以下基本步骤是确定下一个要处理的任务所必需的:
--调度器搜索所有处于就绪/运行状态的任务。
--从处于就绪/运行状态的任务集中，调度程序确定具有最高优先级的任务集。
--在处于就绪/运行状态且优先级最高的任务集中，调度程序找到最早的任务。

## 4.6 调度策略
### 4.6.1 全抢占式调度 Full Preemptive scheduling

完全抢占式调度是指当前正在运行的任务可以根据操作系统预先设定的触发条件,在任何指令下重新调度。一旦高优先级的任务就绪，完全抢占式调度就会将正在运行的任务置于就绪状态。任务上下文被保存，以便被抢占的任务可以在它被抢占的位置继续执行。

完全抢占式调度的延迟时间与低优先级任务的运行时间无关。某些限制与节省上下文所需的(RAM)内存空间的增加，以及任务之间同步所需特性的复杂性的增强有关。由于理论上每个任务都可以在任何位置重新调度，因此与其他任务联合使用的数据访问需要同步。

在图7中，低优先级任务T2不会延迟高优先级任务T1的调度。

![20250114103819](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114103819.png)

在完全抢占系统的情况下，用户应该不断地期望正在运行的任务被抢占。如果一个任务片段不能被抢占，可以通过系统服务 GetResource 暂时阻塞调度程序来实现。

综上所述，在以下所有情况下都会执行重调度(**调度点**):

--成功终止任务(系统服务终止任务，参见13.3.3.2);(**t1执行完后要执行t2就用这个terminate**)

--通过显式激活后继任务成功终止任务(系统服务 ChainTask，见 13.3.3.3);（**t1任务执行完后还要执行一次t1就用这个接t2也行**）

--在任务级别激活任务(如系统服务激活任务，参见 13.3.3.1，消息通知机制，Alarm过期:如果定义了任务激活，参见 9.3);

--显式 wait 调用，此时系统会发生向 Waiting 状态的转换(仅扩展任务、系统服务)WaitEvent,见13.6.3.4;

--设置事件为任务级别的等待任务(如系统服务 SetEvent，参见 13.6.3.1，消息通知机制，Alarm 过期;如果事件设置已定义，请参见 9.3);

--任务级资源释放(系统服务Release Resource，参见13.5.3.2)(**优先级天花板任务，就是一个低优先级的任务得到资源就会将为了防止其他任务抢占资源就会把低优先级的任务提高到资源的优先级，释放了之后就会恢复低优先级任务**);

--从中断级返回到任务级（**中断里触发了更高优先级的任务就会有重调度**）。

在中断服务例程中，不执行重调度(参见图 2)。(因为 ISR 不属于可调度上下文，一旦跳出去就回不来了)。

使用“完全抢占式调度"调度策略的应用不需要系统服务Schedule，而其他调度策略使用该系统服务。为了使可移植的应用程序能够在不同的调度策略下编写，用户可以通过系统服务 schedule 在他/她(指程序员自己)认为正确的 CPU 分配的位置执行重新调度。(**考虑到可移植性这些兼容多个，就直接用户根据情况手写schedule。**)

### 4.6.2 非抢占式调度
如果任务切换只通过一个显式定义的系统服务(显式重调度点)来执行，则调度策略被描述为非抢占式。

非抢占式调度对任务的可能时序要求施加了特殊的限制。具体来说，运行中的低优先级任务的不可抢占部分将高优先级任务的开始延迟到下一个重调度点。

在图8中，优先级较低的任务T2将优先级较高的任务T1延迟到下一个重调度点(在本例中，任务 T2 终止)。

![20250117102034](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117102034.png)

### 4.6.3 重调度点
对于非抢占任务，重调度应在以下情况发生:

--任务成功终止(系统服务终止任务，见13.3.3.2)。
--通过显式激活后继任务成功终止任务(系统服务ChainTask，见13.3.3.3)。
--显式调用scheduler(系统服务Schedule，参见13.3.3.4)。
--当前任务发生了向 Waiting 状态的转换(系统服务 WaitEvent，参见 13.6.3.4)。

注 1:如果传递给 WaitEvent 的事件掩码中有一个事件已经设置，WaitEvent 的调用不会导致等待状态。在这种情况下，WaitEvent不会导致重新调度。非抢占式系统的实现可能规定导致重调度的操作系统服务只能在最高的任务程序级别调用(而不是在任务子函数中)。

![20250117102811](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117102811.png)
(**就是不能在func中调用**)

注2:在这些调度点上的任务切换通常需要保存较少的任务上下文信息。

### 4.6.4 任务组

OS允许任务通过定义任务组来结合抢占式调度和非抢占式调度。对于与组内最高优先级相同或更低优先级的任务,组内任务的行为类似于不可抢占的任务:重调度只发生在 4.6.2中所述的重调度点。对于优先级高于组内最高优先级的任务，组内任务的行为类似于可抢占任务(参见 4.6.1)。

第8.8条描述了使用内部资源定义组的机制。非抢占性任务是内部资源概念最常见的用法;它们是具有特殊内部资源的任务，具有最高的任务优先级。

### 4.6.5 混合抢占调度
如果在同一个系统上混合使用可抢占和不可抢占的任务,则产生的策略称为“混合抢占”调度。在这种情况下，调度策略取决于正在运行的任务的抢占属性。如果正在运行的任务是非抢占式的，则执行非抢占式调度。如果正在运行的任务是可抢占的，则执行抢占调度。

非抢占任务的定义在全抢占操作系统中是有意义的:

--如果任务的执行时间与任务切换的时间大小相同;

--如果要经济地使用RAM来提供空间以保存任务上下文;

--如果任务没有被抢占的需求。

许多应用程序只包含几个执行时间很长的并行任务，对于这些任务，完全抢占式操作系统会很方便。而许多具有确定执行时间的短任务时,非抢占式调度会更有效。对于这种配置混合抢占式调度策略是一种折衷(参见 14.3.5中的设计提示)。

### 4.6.6选择调度策略
软件开发人员或系统集成商通过配置任务优先级和将可抢占性作为任务属性来确定任务的执行顺序。

任务类型(基本或扩展)独立于任务的调度类型(可抢占或不可抢占)。因此，完全抢占式系统可以包含基本任务和非抢占式系统扩展任务。如果 OS 服务正在运行，抢占和上下文切换可能会延迟到服务完成。

## 4.7 任务的终止
在操作系统中，任务只能自行终止(self-terminate)。操作系统提供了ChainTask服务，保证在一个正在运行的任务结束后，立即激活执行另一个特定任务。chain本身会将任务放到优先级队列的最后一个元素中。

每个任务都将在其代码结束时自行终止。当任务结束时,调用Terminate task 或 ChainTask;不这样做会导致未定义的行为。

# 5 应用程序模式
## 5.1 General

应用程序模式被设计为允许操作系统在不同的操作模式下运行。支持的最小应用模式数目为1。它只适用于完全相互排斥的操作模式。两种排他性操作模式的一个例子是行尾编程(end of line programming)和正常操作。操作系统启动后，不允许更改应用程序模式。

## 5.2 应用程序模式范围

许多 ECU 可以执行完全独立的应用程序，例如工厂测试、Flash 编程或正常运行。应用模式是根据这些不同的条件来构造运行在ECU中的软件的一种方式，是开发完全独立系统的一种干净的机制。通常，每个应用程序模式使用它自己的所有任务子集、ISR、Alarm 和时序约束，尽管并没有限制一个任务或ISR不可以运行在不同模式下。如果再次需要使用相同的功能，建议在不同的模式之间共享同一个任务/ISR/Alarm。如果功能不完全相同，就需要在运行时和资源之间权衡:要么动态地检擞τ贸绦蚰Ｊ剑要么定义单独的任务。

考虑到系统的生成和优化，应用程序模式有助于减少需要考虑的操作系统对象的数量。
## 5.3 启动性能
在汽车应用中，ecu的启动性能是一个安全关键(safetycritical)问题，因为在正常运行
过程中可能会出现复位状况。因此，用于确定应用程序模式的代码应该非常快。在启动时，不使用系统服务的用户代码(参见图19)应确定模式,并将其作为参数传递给API服务startos.

说明:如果系统中 OSEK和OSEKtime 同时存在，则使用传递给 OSEKtime 的应用模式。

建议只使用引脚状态或类似容易评估的条件来确定模式。模式应该在内核启动之前确定，并且生成的代码不可移植。应避免冗长或复杂的启动程序。

传递给 startos 的应用程序模式允许操作系统自动启动正确的任务和Alarm 子集。将自动启动任务和报警分配到应用模式时，应在ISO 17356-6文件(第6部分:0SEKNDX实现语言(OIL))中静态进行。

## 5.4 应用程序模式支持
对于一致性类的子集没有应用程序模式的限制。这是所有一致性类的要求。对关闭功能没有影响。不支持在运行时切换应用程序模式。

# 6 中断处理
## 6.1 General
中断(中断服务程序:ISR)细分为两类ISR:

--ISR 类别 1:ISR不使用操作系统服务。(例外情况是一些系统服务启用和禁用中断;参见表 4)。ISR结束后，处理会在中断发生的指令处继续进行，也就是说，中断对任务管理没有影响。这类isr 的开销最小。(**操作系统不知道**)

--ISR 类别 2:操作系统提供ISR框架，为专用用户例程准备运行时环境。在系统生成期间，用户例程被分配给中断。(**操作系统知道**)
在中断服务程序中，操作系统服务的使用根据表4受到限制。

![20250117111634](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117111634.png)
![20250117111749](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117111749.png)

![20250117111952](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117111952.png)
在ISR内部,不能进行重调度。如果一个可抢占的任务被中断，并且没有其他中断是活动的，则重调度发生在ISR类2终止时。

具体实现需确保任务按照调度点执行(参见4.6.1)。为了实现这一点，具体实现可能对所有类别的isr的中断优先级设置限制和/或在配置时执行检查(见 14.3.4.1)。

中断优先级的最大数目取决于所使用的控制器以及具体实现。中断的调度依赖于硬件，ISO 17356中没有指定。中断由硬件调度，而任务由调度器调度。关于中断优先级，可能有14.3.4.1所述的限制。中断可以中断任务(可抢占和不可抢占的任务)。如果一个任务从中断例程被激活，这个任务在所有活动的中断例程结束后被调度。

在中断服务例程中，可以使用表4中列出的系统服务。

**快速禁用/启用 api 函数**

ISO 17356提供了禁用所有中断(参见13.4.2.1,enablealinterrupts, 13.4.2.2,disableallinterrupts, 13.4.2.3,resumealinterrupts和13.4.2.4,suspendallinterrupts)和禁用第2类中断(参见 13.4.2.5,ResumeOsInterrupts 和 13.4.2.6,SuspendosInterrupts)的快速功能。典型的用法是保护短的临界区段。中断程序不能从这种受保护的临界段内的中断中返回，即“暂停禁用"应该有匹配的“恢复/启用”。唯一允许被调用的 Suspend-和Resume-之间的对是进一步的SuspendAlinterrupts/ResumeOsinterrupts- 对或SuspendAllinterrupts/ResumeAllinterrupts-对。

# 7 Event 机制

事件机制:

--是一种同步的手段;

--只提供给扩展任务;

--启动任务的“从 Waiting”与“到 Waiting”的转换。

Event是由OS管理的对象。它们不是独立的对象，而是被分配给扩展任务。每个扩展任务都有一定数量的事件。这个任务称为这些事件的所有者。单个事件由其所有者及其名称(或掩码)标识。当激活扩展任务时，这些事件被操作系统清除。事件可用于将二进制信息传递给它们关联的扩展任务。事件的意义是由应用程序定义的，例如:定时器超时的信号、资源的可用性、消息的接收等。

根据特定任务是事件的所有者还是其他任务(不一定是扩展任务),可以使用各种Options来操作事件。所有任务都可以设置任何非挂起扩展任务的任何事件。只有所有者能够清除其事件并等待其事件的接收。

事件是扩展任务从 Waiting 状态转换到 Ready 状态的准则。操作系统提供设置 setting、清除 Clearing、查询interrogation 和等待 waiting 事件发生的服务。

任何任务或ISR Category2都可以为未挂起的扩展任务设置一个事件，从而通过该事件通知扩展任务任何状态的变化。

事件的接收者总是一个扩展任务。因此，中断服务程序或基本任务不可能等待事件。事件只能由拥有该事件的任务清除。扩展任务只能清除自己的事件，而基础任务不能使用OS服务清除事件。

如果任务正在等待的至少一个事件已经发生，则处于Waiting状态的扩展任务将被释放到 Ready 状态。如果正在运行(处于 running 状态)的扩展任务试图去 wait 某个事件，而该事件已经发生，则该任务将保持running状态。

图10通过设置完全抢占式调度的事件解释了扩展任务的同步,其中扩展任务T1具有更高的优先级。

图10展示了设置事件所影响的过程:TaskT1等待事件。TaskT2为T1设置该事件。调度程序被激活。随后，T1从等待状态转移到就绪状态。由于T1优先级更高，导致任务切换，T2 被 T1抢占。T1 复位事件。之后，T1再次等待该事件，调度程序继续执行 T2。

如果假定是非抢占式调度，则重新调度不会在事件设置之后立即发生(参见图11，其中扩展任务 T1 优先级更高)。

![20250117114810](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117114810.png)


**详注:实际上上面 11是错的，正确的演示图如下图所示。而且上面图画的很粗略，很多地方都没对齐。**
![20250117120052](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250117120052.png)

# 8 资源管理
## 8.1 General
资源管理用于协调多个任务对共享资源的不同优先级的并发访问，例如管理entities(调度器)、程序 sequences、内存或硬件区域。

资源管理对于所有一致性类都是强制性的。

资源管理可以有选择地扩展，以协调任务和中断服务例程的并发访问。

资源管理确保:

--两个任务不能同时占用同一资源;

--不能发生优先级反转:

--使用这些资源不会发生死锁;

--对资源的访问永远不会导致 Waiting 状态。

如果资源管理扩展到中断级别,它还可以保证两个任务或中断例程不能同时占用相同的资源。

资源管理的功能在以下情况下很有用:

--可抢占任务;

--非抢占任务，如果用户打算在其他调度策略下执行应用程序代码;

--在任务和中断服务程序之间的资源共享;

--中断服务例程之间的资源共享。

如果用户不仅需要防止任务造成的中断，而且需要防止中断造成的中断，他/她也可以使用操作系统服务来启用/禁用不会导致重新调度的中断(见第6条和13.4条)。

## 8.2 访问被占用资源时的行为
操作系统规定了优先级天花板协议(见8.6)，因此，不会发生任务或中断试图访问己占用资源的情况。

如果使用资源的概念来协调任务和中断,操作系统也确保只有在中断服务程序执行期间可能被该中断服务程序占用的所有资源都被释放后，该中断服务程序才会被处理。

ISO17356严格禁止对同一资源的嵌套访问。在需要嵌套访问的极少数情况下，建议使用第二个具有与第一个资源相同行为的资源。IS017356-6语言特别支持具有相同行为的资源(所谓的“链接资源”)的定义。

## 8.3 使用资源的限制
当资源被占用时，TerminateTask,Chain Task,Schedule,WaitEvent 不能被调用。中断服务程序不能在资源被占用的情况下完成。

当一个任务占用多个资源时，用户应遵循后进先出原则(stack-like)请求和释放资源

## 8.4 调度器作为资源

如果一个任务保护自己不被其他任务抢占，它可以锁定调度器。调度程序被视为所有任务都可以访问的资源。因此，将生成一个具有预定义名称RES_SCHEDULER的资源。

中断的接收和处理独立于资源 RES_SCHEDULER的状态。当然了，它禁止了任务的重调度(意思是isr中不能重调度)。

## 8.5 同步机制的一般性问题
### 8.5.1 优先级翻转的解释
常见同步机制(例如使用信号量)的一个典型问题是与优先级反转有关的问题。这意味着低优先级任务会延迟高优先级任务的执行。IS0 17356规定了优先级天花板协议(见8.6)以避免优先级反转。

图12显示了两个任务共同访问一个信号量的顺序(在完全抢占的系统中，任务T1优先级最高)，优先级较低的任务T4占用了信号量S1。T1抢占T4 并请求相同的信号量。由于信号量 S1 已被占用，T1进入等待状态。此时低优先级的T4被中断，被优先级介于 T1和 T4之间的任务抢占。T1只能在所有低优先级任务都被终止，并且S1信号量再次被释放后才能执行。尽管 T2 和 T3 没有使用信号量S1，但它们的运行时延迟了 T1。

![20250122113923](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122113923.png)

### 8.5.2 死锁
常见同步机制(如使用信号量)的另一个典型问题是死锁问题。在这种情况下，死锁意味着由于无止境地等待相互锁定的资源，任务无法执行。

下面的场景会导致死锁(参见图13):

任务T1占用信号量 S1，随后无法继续运行，例如等待事件。此时，低优先级任务T2进入运行状态。它占用信号量S2。如果T1再次准备就绪并试图占用信号量s2，它将再次进入等待状态。如果T2试图占用信号量S1，就会导致死锁。

![20250122114946](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122114946.png)

## 8.6 优先级天花板协议

为了避免优先级反转和死锁的问题，操作系统需要以下行为:

--在系统生成时，每个资源都应该静态地分配自己的最高优先级。最高优先级至少应设置为所有访问某个资源或与该资源链接的任何资源的任务的最高优先级。最高优先级低于所有不访问该资源的任务的最低优先级，高于所有访问该资源的任务的最高优先级。

--当任务需要某一资源时，如果当前任务的优先级低于该资源的最高优先级，则该任务的优先级将提升至该资源的最高优先级。

--如果该任务释放了该资源，则该任务的优先级将被重置为需要该资源前动态分配(译者注:怀疑此处有错，应该是静态分配的)的优先级。

优先级天花板会导致优先级等于或低于资源优先级的任务可能出现时间延迟。此延迟受任何低优先级任务占用资源的最大时间限制。

可能与正在运行的任务占用相同资源的任务由于优先级(相比running的任务)低于或相等而不进入运行状态。当某个任务占用的资源被释放后，可能占用该资源的其他任务将进入运行状态。对于可抢占的任务，这是一个重新调度的点。

图14所示的示例说明了优先级天花板的机制。任务T0优先级最高，任务T4优先级最低。任务T1和任务T4需要访问相同的资源。系统清楚地表明,不存在无边界的优先级反转。
高优先级任务 T1等待的时间小于T4占用资源的最大时间。

![20250122115847](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122115847.png)

## 8.7 中断级别扩展的优先级天花板协议
资源管理扩展到中断级别是可选的。

为了确定在中断中使用的资源的最高优先级,应该给中断分配高于所有任务优先级的虚拟优先级。对软件优先级和硬件中断级别的控制取决于实现。

--在系统生成时，每个资源都应该静态地分配自己的最高优先级。最高优先级至少应设置为所有访问资源或与该资源链接的任何资源的任务和中断例程的最高优先级。最高优先级应低于所有不访问该资源的任务或中断例程的最低优先级,同时高于所有访问该资源的任务或中断例程的最高优先级。

--如果一个任务或中断例程需要一个资源,而它的当前优先级低于该资源的最高优先级，则该任务或中断的优先级将被提升到该资源的最高优先级。

--如果任务或中断程序释放了该资源,则该任务或中断的优先级将被重置为需要该资源之前动态分配(译者注:此处应该是静态分配)的优先级。

可能与正在运行的任务或中断例程占用相同资源的任务或中断例程不运行,因为它们的优先级低于或等于正在运行的任务或中断例程。如果一个任务占用的资源被释放，另一个可能占用该资源的任务或中断例程就可以运行。对于可抢占的任务，如果任务的新优先级不是一个中断的虚拟优先级，这是一个重新调度的点。

图15所示的示例描述了以下场景:

抢占任务T1正在运行，请求一个与中断服务例程 INT1 共享的资源。任务T1激活更高优先级的任务T2和T3。由于优先级上限协议的原因，任务T1 仍在运行。中断 INT1 发生。由于优先级上限协议，任务T1仍在运行，中断INT1 正在等待。中断 INT2 发生。中断服务例程 INT2 中断任务 T1 并开始运行。INT2 完成后，继续 T1 任务。任务 T1 释放资源。中断业务例程 INT1 正在执行，任务 T1 中断。在 INT1 完成之后，任务3正在运行。任务 T3 结束后,任务 T2正在运行。任务 T2结束后，任务 T1 继续。

![20250122143810](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122143810.png)

图16所示的示例描述了以下场景:

抢占任务 T1 正在运行。中断INT1 发生。任务T1 中断,中断业务例程INT1 被执行。INT1请求与中断服务例程INT2共享的资源。更高优先中断INT2发生。由于优先级上限协议,INT1仍在执行，INT2正在等待。发生中断INT3。由于INT3的优先级高于INT1,INT3 中断此中断服务例程并执行。INT3 激活任务T2。INT3 完成后,继续INT1。INT1 释放请求的资源后,INT2执行，因为它的优先级高于INT1。INT2 完成后，继续INT1。INT1 完成后，任务T2 再运行，优先级高于任务 T1，任务 T1 已准备就绪。任务 T2 结束后，继续任务 T1。

![20250122144427](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122144427.png)

## 8.8 内部资源

内部资源是用户不可见的资源，因此不能通过系统函数 GetResource 和 ReleaseResource寻址。相反，它们是在一组明确定义的系统功能内部严格管理的。此外，内部资源的行为与标准资源完全相同(优先级上限协议等)。

内部资源仅限于任务。在系统生成过程中，一个任务最多只能分配一个内部资源。如果将内部资源分配给某个任务，则内部资源应按以下方式管理:

--该资源将在任务进入运行状态时自动获取(但在任务被激活时不会)，除非它已经获取了该资源。任务的优先级会自动调整为资源的最高优先级。

--在 4.6.2定义的重调度点，资源将自动释放。具体实现可能会优化，例如，在需要重新安排时，只释放/获取系统服务Schedule内的资源。

请注意:当任务被抢占时，内部资源不会被释放。

对于分配了相同内部资源的任务的行为在4.6.4中描述。不可抢占的任务是一个特殊的组，其内部资源与分配的RESSCHEDULER具有相同的优先级(参见4.6.2)。当需要避免在一组任务中进行不必要的重新调度时，可以在所有情况下使用内部资源。一个系统中可以定义多个组(多个内部资源)。典型示例见 14.3.6。

某些系统调用必须在资源被占用的情况下调用(见8.3)的一般限制不适用于内部资源,因为内部资源是在这些调用中处理的。(**从写操作系统的角度和用操作系统的角度**)但是，所有标准资源应在内部资源发布之前发布(见8.3)。

分配相同内部资源的任务具有一定的优先级范围。在相同的优先级范围内，可能有不使用此内部资源的任务。应用程序将决定这是否有意义。

# 9 Alarm
## 9.1 General

操作系统提供处理重复事件的服务。这些事件可能是，例如，提供定期中断的timer，或轴(凸轮轴或曲轴)的角度不断变化的情况下产生中断的编码器，或其他常规应用程序特定的触发器。Os提供了两个阶段的概念来处理此类事件。重复发生的事件(源)由具体实现特定的计数器记录。操作系统软件通过计数器向应用软件提供 Alarm机制。

## 9.2 计数器
计数器由计数器值(以“ticks"度量)和一些特定于计数器的常数表示。

操作系统没有提供标准的API来直接摄作计数器。

操作系统负责在计数器溢出时管理Alarm的必要操作，以及计数器如何溢出。

操作系统提供了至少一个来自(硬件或软件)计时器的计数器。

## 9.3 Alarm 管理

操作系统提供激活任务、设置事件、告警超时回调等服务。警报回调例程是应用程序提供的一个短函数。

当达到预定义的计数器值时，警报将触发。该计数器值可以相对于实际计数器值(相对告警)定义，也可以定义为绝对值(绝对告警)。例如，当接收到一些定时器中断时，当到达一个特定的角度位置时，或者当接收到一条消息时，警报可能会触发。

告警可以定义为单个告警,也可以定义为循环告警。同时,操作系统还提供了告警取消、告警当前状态获取等服务。

一个计数器可以连接多个警报。

Alarm在系统生成时静态产生:

--1个计数器

--和1个任务或一个报警回调程序。

根据配置，该告警回调例程应被调用，或该任务应被激活，或在告警触发时为该任务设置一个事件。运行报警回调例程时应该禁用二类中断。表4列出了告警回调例程中允许的系统服务。当告警触发时，任务激活和事件设置与普通任务激活和事件设置具有相同的属性。

计数器和告警是静态定义的。将告警分配给计数器，以及在告警触发时执行的操作，也是静态定义的。

动态参数为告警触发时的计数器值，以及循环告警的周期。

![20250122151546](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122151546.png)

## 9.4 告警回调例程
告警回调例程既不能有参数也不能有返回值。

报警回调例程应采用以下格式:
![20250122151628](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122151628.png)

警报回调例程的处理级别是被调度器，或isr使用的级别，具体取决于实现。

# 10 Messages
为了使具体实现一致，应提供处理器内部通信的消息处理，所需的最低功能是 ISO17356-4 所述的 CCCA。CCCB 是唯一另一个可接受的，因为它是 CCCA 的超集。

如果一个实现提供了在 IS0 17356-4 中描述的其他一致性类中指定的甚至更多的功能,则该实现应坚持相应的IS0 17356-4 功能的语法和语义。

请注意，对于信息，ISO 17356-4规定的规则是有效的。例如，IS017356-4系统接口不调用 ErrorHook。但是,如果 ISO 17356-4 功能在内部调用一个操作系统服务,如 ActivateTask,则需要从 ActivateTask 调用 ErrorHook。详情请参阅 ISO 17356-4。

# 11错误处理、追踪和调试
## 11.1 钩子例程
操作系统提供了系统特定的钩子例程，允许用户定义在Os内部处理的actions。这些钩子例程是:

--由OS调用，在取决于操作系统具体实现的特定上下文中;
--优先级高于所有任务;
--不被二类中断程序中断:
--操作系统的一部分;
--由用户实现具有用户定义的功能;
--接口标准化，但功能不标准化(钩子例程本身的环境和行为)，因此通常使钩子例程不可移植;
--只介许使用API系数的子集(见表41);
--是强制性的，但可以通过 ISO 17356-6进行配置。

在操作系统中，钩子例程可以用于:

--系统启动(见 11.3):相应的钩子例程(StartupHook)在操作系统启动之后和调度程序运行之前被调用。

--系统关闭(见 11.4):对应的钩子例程(ShutdownHook)在应用程序请求系统关闭时调用，或者在发生严重错误时由操作系统调用。

--跟踪或依赖于应用程序的调试目的，以及上下文切换的用户定义扩展(见 11.5)。

--错误处理。

每个Os的具体实现应该描述钩子例程的约定。

如果应用程序在钩子例程中调用了一个不允许的API服务，则行为没有定义。

如果引发错误，则实现应返回特定于实现的错误代码。

大多数操作系统服务不允许使用钩子例程。此限制对于降低系统复杂性是必要的。

## 11.2 错误处理
### 11.2.1 总论
OS提供错误服务来处理操作系统中临时和永久发生的错误。其基本框架是预定义的，由用户完成。这让用户可以选择高效的集中或分散错误处理。

区分两种不同类型的错误:

--应用程序错误:操作系统无法正确执行请求的服务，但假定其内部数据是正确的。在这种情况下，调用集中式错误处理。另外，操作系统通过状态信息返回错误，进行分散式错误处理。由用户根据所发生的错误来决定要做什么。

--致命错误:操作系统不能再假定其内部数据是正确的。此时操作系统调用集中式的系统关机。

所有这些错误服务都分配了一个指定错误的参数。操作系统将提供两种级别的错误检查:标准状态和扩展状态。如果任务在标准状态的版本下被 activate,返回 E_OK 或 Too many task activation。另外，在扩展状态的版本中，还可以返回额外的返回值“Task is invalid"或"Task 仍占用资源"等。这些扩展的返回值在运行时不再需要出现在目标应用程序中，即相应的错误不会在操作系统的运行时版本中被截获(只是一种调试机制)。

API服务的返回值优先于输出参数。如果一个API 服务返回一个错误，输出参数的值是未定义的。

### 错误钩子例程

如果系统服务返回的 statusType 值不等于E_OK，则调用错误钩子例程(ErrorHook)。如果从 ErrorHook本身调用系统服务，则不会调用该钩子例程 ErrorHook(也就是说，永远不会出现对错误钩子的递归调用)。从ErrorHook调用系统服务时，任何可能发生的错误只能通过计算返回值来检测。

如果在内部调用的任务激活或事件设置期间检测到错误,例如在警报触发或消息到达时，ErrorHook 也会被调用。

### 11.2.3 错误管理
为了在 ErrorHook中实现有效的错误管理，用户可以访问附加信息。图18总结了错误管理的逻辑架构。

宏 OSErrorGetServiceld()提供了引发错误的服务标识符。服务标识符的类型是OsServiceldType。取值为OsServiceld_xxxx，其中xxxx为系统服务名称。OSErrorGetServiceld的实现是必须的。如果提供了调用ErrorHook的系统服务的参数，则以下访问宏名称构建方案应使用: OSError_Name1_Name2，其中:

--Name1:系统服务名称

--Name2:是ISO 17356-3中的参数的正式名称
例如，用于访问 SetRelAlarm 参数的宏如下:

--OSError _SetRelAlarm_AlarmID()

--OSError _SetRelAlarm_increment()

--OSError SetRelAlarm_cycle()
如果参数是对象标识符，则访问系统服务第一个参数的宏是必需的。为了优化，可以在ISO 17356-6中关闭宏访问。

![20250122162743](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122162743.png)
![20250122162826](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122162826.png)

### 11.2.3 错误管理
为了在 ErrorHook中实现有效的错误管理，用户可以访问附加信息。图18总结了错误管理的逻辑架构。

宏OSErrorGetServiceld()提供了引发错误的服务标识符。服务标识符的类型是OsServiceldType。取值为OsServiceld_xxxx，其中xxxx为系统服务名称。OSErrorGetServiceld的实现是必须的。如果提供了调用ErrorHook的系统服务的参数，则以下访问宏名称构建方案应使用:OSError Name1 Name2，其中:

--Name1:系统服务名称

--Name2:是ISO17356-3中的参数的正式名称

例如，用于访问 SetRelAlarm 参数的宏如下:

--OSError_SetRelAlarm_AlarmlD()

--OSError_SetRelAlarm_increment ()

--OSError setRelAlarm_cycle()

如果参数是对象标识符，则访问系统服务第一个参数的宏是必需的。为了优化，可以在IS0 17356-6中关闭宏访问。

## 11.3 系统 Startup
处理器复位后的初始化取决于具体实现，但OS提供了对标准化初始化方式的支持。

实现应明确定义硬件、操作系统和应用程序的初始化接口。

ISO 17356的这一部分并没有强制应用程序定义在操作系统初始化后需要启动的特殊任务，但它允许用户在生成系统时指定自动启动任务和自动启动警报。

CPU 复位后，会执行与硬件相关的应用程序(无OS背景)。不可移植部分以检测应用程序模式结束。出于安全原因，此检测不应依赖于系统运行历史。

在 Os 和 OSEKtime os 共存的系统中(图 19 没有反映),始终先运行 OSEKtime 初始化,ISO17356 初始化的剩余部分在 OSEKtime 进入空闲循环后执行。这将导致 OSEKtime 自动调用startos，并将应用程序模式作为参数传递给OSEKtime。

否则，应用程序的可移植部分从调用启动操作系统的函数开始。以应用程序模式为参数的 startos。在操作系统初始化之后(调度程序没有运行),startos 调用钩子例程 startupHook,用户可以在那里放置所有与操作系统相关的初始化代码。为了根据启动的应用模式来构造StartupHook 中的初始化代码，提供了 GetActiveApplicationMode 服务。从钩子例程返回后,操作系统启用中断并启动调度程序。然后系统运行并执行用户任务。

![20250122163614](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122163614.png)

系统启动包括以下步骤(见图 19):

a)复位后，用户可以自由执行(不可移植)特定于硬件的代码。在第5阶段之前，不允许中断第2类或操作系统服务。不可移植部分通过检测应用程序模式结束。

b)以应用模式为参数调用 startos。这个调用启动操作系统(如果存在 OSEKtime，这是自动完成的)。

c)OS 内部启动功能。

d)操作系统调用钩子例程 startupHook，用户可以在那里放置初始化过程。在这个钩子例程中，所有的用户中断都被禁用。

e)操作系统允许用户中断并启动调度活动。操作系统启动为当前应用模式声明的自动启动任务和告警。没有定义同等优先级的自动启动任务的激活顺序。自动启动告警前，需要先执行任务的自动启动。

注意:如果可能，在告警自动启动前，通过系统初始化将计数器置零。例外是日历计时器等。
对于自动启动的告警，所有值均为相对值。

## 11.4 系统 Shutup
ISO 17356-3 定义了一个用于关闭操作系统的服务，即 shutdownnos。

由于致命错误，应用程序或操作系统可能请求此服务。

调用 shutdownnOs 时，操作系统调用钩子例程 shutdownHook，然后关闭。

在 shutdownHook中，用户通常可以自由定义任何系统行为，例如不从例程返回。(参见 13.8.2.3)。然而，在 Os与 OSEKtime 操作系统共存的情况下，在 shutdownHook 中可能会执行一些功能方面的限制。可能只有操作系统被关闭，而OSEKtime操作系统保持不变。因此，在 OSEKtime 内处理的 I/O 设备在 shutdownHook 中不应复位，ShutdownHook 应返回。

## 11.5 调试

两个钩子例程(PreTaskHook和 PostTaskHook)在任务上下文切换时被调用。

这两个钩子例程可以用于调试或时间测量(包括上下文切换时间)。因此，每次直接在旧任务之前调用 PostTaskHook;每次有新任务进入运行状态后，都会直接调用PreTaskHook。因为任务仍然/已经处于运行状态，GetTaskld将不会返回INVALID task。

当一个任务正在运行时调用了shutdownOs,shutdownos 可能调用也可能不调用PostTaskHook。如果调用了 PostTaskHook，如果它在 shutdownHook之前或之后被调用，则它是未定义的。

![20250122171713](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250122171713.png)

# 12 系统服务描述
## 12.1 系统对象的定义
在操作系统中，所有系统对象都由用户静态确定。操作系统供应商应提供操作系统对象的定义。对象(惟一名称和特定特征)的实际创建是在系统生成阶段完成的。在应用程序源代码中完成的声明是对那些OS对象的外部引用。没有系统服务可用于动态创建系统对象。声明提供了正在使用的系统对象的信息，该对象是在另一个位置创建的。这些名称用作系统服务中的标识符。

通常这些名字的作用域类似于c语言中的外部变量。

系统对象的内部表示是特定于实现的。系统对象的实现有多种替代方案。例如，TaskType可以被实现为指向任务数据结构的指针，也可以被实现为指向相应列表元素的索引。应用程序程序员不应该假定一个特定的表示。

系统对象的创建可能需要额外的工具，使用户能够添加或修改定义中指定的值。因此，用于此效果的系统生成和工具也是特定于实现的。

## 12.2 约定
### 12.2.1 调用类型

系统服务接口为ISO/ANSI-C。它的实现通常是一个函数调用，但也可以根据实现的需要以不同的方式解决，例如通过C预处理器的宏。不应假定具体的实现类型。

### 12.2.2 调用的合法性
系统服务从任务、中断服务例程、钩子例程和报警回调中调用。根据系统服务的不同，它们的可用性可能存在限制。一致性类施加了进一步的限制。

表4列出了所有系统服务，并显示了允许调用它们的情况(V)。

![20250123103826](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250123103826.png)
![20250123103919](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250123103919.png)

### 12.2.3 错误特征
为了保持系统的高效和快速，操作系统不会测试所有的错误。如果应用程序不正确使用操作系统服务，可能会导致未定义的系统行为。

大多数系统服务都会向用户返回一个状态。如果可以不受任何限制地执行系统服务，则返回状态为EOK。如果系统识别到异常条件限制了系统服务的执行，则返回不同的状态。

E_OK 以外的状态可能是不被认为是错误的信息(“警告”)。例如，系统服务 CancelAlarm的返回状态为需要取消的告警已经过期。因此，用户程序被告知，例如，一个不需要的任务激活已经发生。检测“Warnnings"是系统服务的一部分。

如果可以在运行时之前排除错误，则运行时版本可能会忽略对这些错误的检查。如果唯一可能的返回状态是EOK，则实现可以不返回状态。

系统服务的所有返回值都列在各自的描述下。返回状态区分了“标准"和“扩展"状态。“标准”版本满足前面所述的调试应用系统的要求。根据上面的描述，在标准模式下返回的非EOK状态是一个“警告"。“扩展”版本被认为支持对尚未完全调试的应用程序进行测试。与标准版本相比，它包含了扩展的错误检查。

操作系统内部错误检查的顺序没有指定。每当出现多个错误时，将哪个状态返回给应用程序取决于实现。如果应用程序出现错误,操作系统将调用钩子例程 ErrorHook(如果定义了)。

ErrorHook的目的是将状态信息集中处理。

ErrorHook 例程只在生成E OK 以外的返回值时被调用。

ErrorHook 例程是在 IS0 17356-6 文件中配置的。

对于ErrorHook例程管理，标准状态管理对应的标准模式与扩展状态管理对应的扩展模式是有区别的。

系统向 ErrorHook 例程传递额外的信息。出于性能和栈消耗的原因，使用了一个全局结构，包括关于最后一个错误的补充信息。这个全局结构在执行时根据给定的服务和给定的实现约束进行填充。为了实现高效和自适应的实现,没有规定这种错误管理结构的格式。然而，为了在 ErrorHook 例程中实现源代码的可移植性，定义了用于访问不同参数的标准化宏。

在致命错误的情况下，系统服务不会返回应用程序，而是激活ShutdownOS。例如，系统服务中未检测到的错误参数导致系统不一致。传递给ShutdownOS的参数是一个依赖于实现的系统错误代码。系统错误码是一个数字范围，不会与操作系统服务的状态冲突。

shutdownOs的功能与实现有关。可能的实现是停止应用程序或发出断言。应用程序本身可以访问 shutdownos 以受控的方式关闭操作系统。在处理不可分配的错误(例如“非法指令代码”)时，也建议调用 shutdownos。这不是强制性的，因为硬件支持是必要的，不能想当然。

# 13.1 基础
## 13.1.1 描述结构

操作系统业务按逻辑分组。为任务管理、中断管理等所有服务提供了一致的描述。

每个逻辑组的描述都从数据类型定义开始。下面是对特定于组的结构元素和系统服务的描述。最后一项是常量和任何其他约定的描述。

## 13.1.2 结构化元素

结构化元素的描述包含以下字段:

--语法:类c语法的接口;

--Perameter (ln):所有输入参数列表;

--说明:结构要素说明;

--特殊性:解释与使用有关的限制;

--一致性:指定提供结构元素的一致性类。

## 13.1.3 服务描述
服务描述包含以下字段:

--语法:类c语法的接口:

--Parameter(ln):所有输入参数列表;

--Parameter(Out):所有输出参数列表;

--描述:OS服务功能说明;

--特殊性:解释使用操作系统服务的限制;

--状态|可能返回值列表:

    --标准:操作系统标准版本提供的返回值列表。特殊情况:服务不返回;
    
    --Extended:操作系统扩展版本的附加返回值列表;

--一致性:指定提供操作系统服务的一致性类。

操作系统服务规范对数据类型的命名约定如下:

--...Type:描述单个数据(包括指针)的值;
--...RefType:描述一个指向...类型(用于引用调用)。

## 13.2 通用数据类型

### 13.2.1 StatusType
此数据类型用于API服务提供的所有状态信息。命名约定:API服务的所有错误都应该以E开头。为操作系统保留的应该以EOS开始。

正常的返回值是EOK，它与值0相关联。

定义了以下错误值。

### 13.2.2 API服务的所有错误码

- E_OS_ACCESS=1,
- E_OS_CALLEVEL=2,
- E_OS_ID=3,
- E_OS_LIMIT =4,
- E_OS_NOFUNC =5,
- E_OS_RESOURCE =6,
- E_OS_STATE=7,
- E_OS_VALUE= 8,

如果唯一可能的返回状态是E_OK，则实现可以不返回状态;这并没有在个别服务的描述中单独说明。

### 13.2.3 OS的内部错误

这些错误是特定于实现的，不是可移植部分的一部分。错误名与上述API服务的错误名位于相同的名称空间中，即数字范围不得重叠。为了显示使用上的差异，名称内部错误应该以E_OS_SYS 开头.

E_OS_SYS_STACK,

E OS SYS_PARITY,

以及其他特定于实现的错误，应在特定于供应商的文档中描述。….

操作系统内部错误的名称和范围与其他服务(如通信和网络管理)的名称和范围或 API错误值的范围不重叠。详情请参考ISO17356-2。

## 13.3 任务管理
### 13.3.1 数据类型
--TaskType:该数据类型标识一个任务。

--TaskRefType:该数据类型指向 TaskType 的一个变量。

--TaskstateType:该数据类型标识任务的状态。

--TaskStateRefType:该数据类型指向一个数据类型为TaskStateType 的变量。
### 13.3.2 结构化元素

#### 13.3.2.1 DeclareTask

--Syntax: DeclareTask (<Taskldentifier>);
--Parameter(ln):
  --Taskldentifier: Task identifier (C-identifier);
--描述:DeclareTask用作任务的外部声明。此服务的功能和使用类似于变量的外部声明。

--特性:
--一致性类: BCC1，BCC2，ECC1,ECC2.