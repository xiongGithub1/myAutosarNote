
## 介绍



汽车应用的特点是具有严格的实时要求。因此，操作系统(0S)提供了必要的功能来支持事件驱动(event driven)的控制系统。

指定的操作系统服务是实现各厂商软件模块集成的基础。为了能够对单个控制单元的特定特性做出反应，而决定于它们的性能和对资源的最低消耗需求，主要的重点不是实现应用程序模块之间的100%兼容性，而是它们的直接可移植性。

由于操作系统旨在用于任何类型的控制单元，它支持在广泛的硬件上的时间关键(time critical)应用程序。高度的模块化和灵活配置的能力是使操作系统适合低端微处理器和复杂控制单元的先决条件。这些需求已经被“一致性类”定义(见 3.2)和特定于应用程序的适应的特定能力所支持。

对于时间紧迫的应用程序，系统对象的动态生成被丢弃了 。(**动态生成就是类似malloc又不确定性**)。相反，系统对象的生成被分配给系统生成阶段。操作系统内的错误查询可以在很大程度上避免，从而不会不必要地影响整个系统的速度。(**在实际应用中可以把一些没用的错误查询关掉,DET**)另一方面，定义了具有扩展错误查询的系统版本。它适用于测试阶段和时间要求较低的应用程序。即使在这个阶段，也确保了定义(**api**)的统一系统外观(**api是确定的，就是打开扩展错误查询和不打开扩展错误查询的代码是一样的，不需要重新写**)。

## 0.1.1标准接口
应用软件与操作系统之间的接口由系统服务(system service)定义。对于各种处理器家族上的操作系统的所有实现，接口是相同的。

系统服务指定为ISO/ANSI-C类语法(也就是说API是C定义的)，但是没有指定系统服务的实现语言。

## 0.1.2 可伸缩性
不同的一致性类(**不同的配置等级**)、各种调度机制和配置特性使操作系统适用于广泛的应用程序和硬件。该操作系统被设计为只需要最少的硬件资源(RAM、ROM、CPU 时间)，因此甚至可以在8 位微控制器上运行。

## 0.1.3 错误检查
OS提供了两个级别的错误检查，开发阶段的扩展状态和生产阶段的标准状态。

扩展状态允许对调用OS服务进行增强的合理性检查。由于附加的错误检查，它比标准版本需要更多的执行时间和内存空间。然而，在测试阶段可以发现许多错误。在消除了所有错误之后，可以使用标准版本重新编译系统。

## 0.1.4 应用程序移植
ISO 17356 的目标之一是支持应用软件的可移植性和可重用性。因此，应用程序软件和操作系统之间的接口由具有定义良好的功能的标准化系统服务定义。使用标准化的系统服务可以减少维护和移植应用程序软件的工作量和开发成本。

api例子：
![20250109190257](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250109190257.png)

可移植性意味着能够将一个应用软件模块从一个 ECU 转移到另一个 ECU,而无需对应用程序内部进行更大的更改。操作系统的标准化接口(服务调用、类型定义和常量)支持源代码级别的可移植性。目标代码(obiect code)的交换不是 ISO 17356 规定的。

应用程序软件部署在操作系统上，与应用程序特定的IO系统接口是 parallel的，这些 IO接口在 IS0 17356 中没有标准化。应用软件模块可以有多个接口。有用于实时控制和资源管理的操作系统接口，但也有用于表示系统中完整功能的其他软件模块的接口，如果应用程序直接工作在微控制器上，至少也有用于硬件的接口。

![20250109190740](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250109190740.png)

**注意:OSEK OS 允许应用程序通过 API 直接操作硬件，即图中IO system 部分。**
在将应用软件从一个 ECU 移植到另一个 ECU 的过程中，必须考虑软件开发过程的特点、ECU 的开发环境和硬件架构，例如:
--软件开发指导方针;
--文件管理系统;
--编译器的数据分配和栈使用;
--ECU 的内存结构(memory architecture);
--ECU 的时序行为(timing behaviour);
--不同的单片机专用接口，如端口、A/D 转换器、串行通信和看门狗定时器;
--API调用的设计
这意味着规范不足以完全描述实现。实现应该提供特定的文档。(**每家os实现时特殊需要提供自己的说明文档，就类似c语言大致规范是有的，不同的编译器细节有差异**)

## 0.1.5 移植的支持
认证过程确保了不同实现与规范的一致性。本标准第 14 条收集实现的具体细节，这些细节应被视为提高应用程序在不同实现之间的可移植性。这里只考虑应用程序的操作系统接口。(**没有考虑IO实现的移植**)

## 0.1.6车规级需求的特殊文持
对操作系统的特定要求在汽车控制单元软件开发中不断增加。以下特性满足可靠性、实时性和成本敏感性等需求:

--操作系统静态配置和扩展。用户静态地指定所需的任务、资源和服务的数量。
--操作系统规范支持能够在 ROM 上运行的实现，即代码可以从只读内存中执行。
--操作系统支持应用任务的可移植性。
--操作系统规范提供了一个可预测的(**就是对任务执行时间有预测性能计算出来的，最坏情况下的执行时间，比如刹车要求20ms必须响应**)和文档化的行为,使操作系统实现能够满足汽车实时需求。
--操作系统的规范允许实现可预测的性能参数。(**静态就是可预测的，动态就是不可预测的****)

## 0.2 本文档目标
下面的描述被认为是一个通用的描述，对于任何操作系统的实现都是强制性的。这涉及策略和功能的一般描述、调用的接口、参数的含义和声明以及可能的错误代码。

IS0 17356 的这一部分保留了一定的灵活性。一方面，该描述足够通用，适合未来的升级;另一方面，部分描述是显式指定并且是“具体实现相关”的。

任何实现都定义了所有“具体实现相关”的事项。实现支持的一致性类(**四种级别**)被精确地指出。并且特定于实现的问题被记录下来。(**对于每一种情况具体实现是准确的**)

因为这种描述是强制性的,所以只在涉及一般系统策略时才进行定义。在所有其他方面,由系统实现决定对特定硬件类型的最佳适配。

## 0.3 本文档结构
### 0.3.1 General
简要介绍本标准的各条款：
### 0.3.2 第3 条-操作系统“os”的架构
本章主要介绍操作系统的设计原则和体系结构。
### 0.3.3 第4条-任务管理
本节解释使用不同任务类型和调度机制的任务管理，
### 0.3.4第5条-应用模式
本节描述应用程序模式以及如何支持它们。
### 0.3.5 第6条-中断处理
### 0.3.6第7条-事件机制
本章解释了事件机制和不同调度的不同行为。
### 0.3.7 第8条-资源管理
本章描述了资源管理，并讨论了优先级天花板机制的好处和实现。
### 0.3.8第9条-Alarm
本节描述了两个阶段的概念，以支持基于时间的事件(如硬件定时器)和非基于时间的事件

### 0.3.9 第 10 条-消息
IS0 17356-3 增加了处理器内部通信的消息处理。IS0 17356-4描述了完整的消息处理要实现的确切子集在 ISO 17356-4 中有描述。
### 0.3.10 第 11 条-错误处理、跟踪和调试
本节描述实现集中错误处理的机制。它还描述了用于初始化和关闭系统的服务。
### 0.3.11 第 12 条-系统服务的描述
描述时使用的约定。
### 0.3.12第13条b作系统服务的规范
本条款描述了用户可以使用的所有操作系统服务。描述的结构对于任何服务都是相同的,它包含用户需要的有关于 service 的所有信息。
### 0.3.13 第 14 条-具体实现相关和特定应用相关的话题
本章讲述所有特定于操作系统的话题，如服务、数据类型和常量。

## 0.4 总结
### 0.4.1 General
操作系统提供了一个不同服务(**api**)和处理机制(**同步异步**)的池。它是根据用户在系统生成时的配置指令构建的。

描述了四个一致性类，旨在满足关于操作系统功能和能力的不同需求。这样，用户就可以根据控制任务和目标硬件来调整操作系统。**操作系统不可在运行时被动态修改。**

为某个一致性类编写的应用程序可以移植到同一个类的实现。这是由服务的定义、它们的功能范围和每个一致性类的行为来确保的。只有当一个一致性类的所有服务都以确定的能力范围提供时，操作系统实现才符合IS0 17356-3。服务组是按照功能来组织的。

### 0.4.2 任务管理
任务管理包括:
--任务的激活和终止:
--任务状态管理和任务切换管理。

### 0.4.3 同步
操作系统支持以下方式使同步生效:
--资源管理;
--对共同使用的(逻辑)资源或设备的不可分割的操作的访问控制,或对程序流的控制;
--事件控制:
--任务同步的事件管理。
### 0.4.4 中断管理
这包括中断处理服务。
### 0.4.5 Alarm
可以是相对的，也可以是绝对的。Alarny
### 0.4.6 处理器内消息处理
这包括用于数据交换的服务。
### 0.4.7 错误处理
这包括在出现各种错误时支持用户的机制。


## 1范围
OSEK/VDX 是汽车行业的一个联合项目。它旨在为汽车分布式控制单元提供一个开放式架构的行业标准。
IS0 17356 的这一部分描述了能够多任务处理的实时操作系统的概念,可用于机动车辆。它不是与特定实现相关的产品描述。它还指定操作系统应用程序接口(Application ProgramInterface, APl).
通用惯例、术语解释和缩写已在 IS0 17356-1中包括。IS0 17356-6描述了实现和系统生成方面的内容。
该操作系统规范为汽车控制单元应用软件提供了一个支持资源高效利用的统一环境。该操作系统是用于分布式嵌入式控制单元的**单处理器操作系统**。

## 2 引用标准
以下参考文件是本文档应用中不可缺少的参考文件。对于标注日期的参考文献，只有引用的版本适用。对于未注明日期的引用，引用文件的最新版本(包括任何修订)适用。

IS0 17356-1，道路车辆。嵌入式汽车应用的开放接口。第1部分:一般结构和术语、定义和缩写术语
IS0 17356-2，道路车辆。嵌入式汽车应用的开放接口。第2部分:绑定 OS:COM 和NM的 OSEK/VDX 规范
IS0 17356-6,道路车辆。嵌入式电子设备的开放接口。第6部分:OSEK/DX 实现语言(OIL)。

## 3 OS的架构
### 3.1 处理等级
操作系统是相互独立的多个应用程序运行的基础,并在处理器上提供应用程序运行环境。
该操作系统能够控制多个并行运行的进程的实时执行。

操作系统为用户提供了一组定义好的接口。这些接口由竞争 CPU的 entities 使用。Entities有两种类型:
--由操作系统管理的中断服务程序；
--任务(基本任务和扩展任务)。
控制单元的硬件资源可以由操作系统服务管理。这些操作系统服务由统一的接口调用要么由应用程序调用，要么在操作系统内部调用。
操作系统定义了三个处理级别:
--中断级;
--调度程序的逻辑级;
--任务级。
在任务级别内，任务根据用户分配的优先级进行调度(非优先级、全优先级或混合优先级)。运行时上下文在任务执行开始时被占用，并在任务完成后再次被释放。
![20250113184317](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250113184317.png)

制定了下列优先级规则:
--中断优先于任务。
--中断处理级别由一个或多个中断优先级组成。
--中断服务例程有一个静态分配的中断优先级。
--中断服务程序分配到中断优先级取决于具体实现和硬件架构。
--对于任务优先级和资源天花板优先级(**解决优先级反转**)，数字越大表示优先级越高。
--任务的优先级由用户静态分配。(任务优先级的含义见4.5。)
用于处理 task 和 ISR 的处理 level 定义为一系列连续的值。操作系统优先级到硬件优先级的映射是特定于实现的。

说明:为调度程序分配优先级只是一个逻辑概念，甚至可以在不直接使用优先级的情况下实现。此外，它没有规定任务优先级和特定微处理器体系结构相关的硬件中断level的任何规则。

### 3.2 一致性类
应用软件对系统的各种需求和特定系统的各种能力(如处理器、内存)要求操作系统具有不同的功能。在下面的描述中，这些操作系统特性被描述为“一致性类“(CC)。

一致性类的存在是为了支持以下目标:

--提供方便的操作系统功能组，以便更容易理解和讨论操作系统;

--允许部分实现(可能被认证为兼容的)沿着预定义的路线;

--创建从功能较低的类到功能较高的类的升级路径,而不使用相关特性更改应用程序。

要获得认证，应实现完整的一致性等级。然而，系统生成只需要链接特定应用程序所需的那些系统服务。在运行时无法更改一致性等级(也就是说必须配置时确定)。

一致性类由以下属性决定:

--任务激活的多个请求，如4.3 所述;

--任务类型，如 4.2.4 所述;

--每个优先级的任务数。

如果没有明确说明，所有其他功能都是强制性的。

![20250114085514](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114085514.png)

定义了以下一致性类:

--BCC1(只有基本任务，每个任务一个激活请求，每个优先级一个任务，而所有任务有不
同的优先级);

--BCC2(类似于 BCC1，但是每个优先级支持一个以上的任务，允许多个任务激活请求);

--ECC1(类似于 BCC1，加上扩展任务);

--ECC2(与ECC1类似，但是每个优先级支持多个任务，并且允许基本任务有多个任务激活请求)。

只有在不超过最低要求的情况下，才能假定应用程序的可移植性。一致性类的最低要求显示在表1中。
![20250114085932](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114085932.png)

### 3.3 0s 和 OSEKtime os 的关系

OSEKtime os (www.osek-vdx.org)是一个特别适合时间触发架构需求的操作系统。它允许IS0 17356-3与 OSEKtim手操作系统共存。从概念上讲，OSEKtime 分配它的 idle time 给 ISO17356-3 的 task。OSEKOS 的中断和任务的重要性低于(表现为优先级低)OSEKtime os 中类似的 entities.

如果 OSEK OS与OSEKtime共存,OSEK OS接口和系统调用的定义不会改变。由于OSEKtime负责整个系统，而OS只负责本地，所以在系统启动和关闭方面有一些小的例外。这些偏差在ISO 17356的这一部分中特别提到。

在此之上，在 OSEKtime 中定义的功能对 OSEKOS 的实现施加了限制J如果 OSEKOS 打算与 OSEKtime操作系统共存的话。如需更多信息，请参阅说明书OSEKtime 操作系统。

## 4 任务管理
### 4.1 任务概念
#### 4.1.1 General
复杂的控制软件可以方便地按实时性要求划分为不同的执行部分。这些部分应通过任务来实现。任务为函数们的执行提供了框架。操作系统提供任务的并发和异步执行。调度程序组织任务执行的顺序。
操作系统提供了一种任务切换机制(参见scheduler,4.4)，包括一种在没有其他系统或应用程序功能处于活动状态时处于活动状态的机制。这种机制称为空闲机制。操作系统提供了两种不同的任务概念:

--基本任务;

--扩展任务。

#### 4.1.2 基本任务
基本任务只有在以下情况下才会释放处理器:
--他们终止;
--操作系统切换到更高优先级的任务;
--或一个中断发生，导致处理器切换到一个中断服务程序(ISR)。

#### 4.1.3 扩展任务
扩展任务与基本任务的区别在于允许使用Os WaitEvent,这可能会导致等待状态(参见第7章和13.6.3.4节)。等待状态允许释放处理器并将其重新分配给低优先级的任务，而不需要终止正在运行的扩展任务。

从操作系统的角度来看，扩展任务的管理在原则上比基础任务的管理更加复杂，需要更多的系统资源。

### 4.2 任务状态模型
#### 4.2.1 General
下面的文本描述了这两种任务类型的任务状态和状态之间的转换。

一个任务应该能够在多个状态之间变化,因为处理器在任何时候只能执行一个任务的一条指令，而多个任务可能在同一时间竞争处理器。操作系统负责在必要时连同任务状态转换起保存和恢复任务上下文。

#### 4.2.2 扩展任务
扩展任务有四种任务状态:

--运行:在运行状态下，任务被分配给CPU，使其指令可以执行。在任何时间点，只有一个任务处于该状态，而其他所有状态可以被多个任务同时采用。

--就绪:转换到运行状态的所有功能先决条件都已经存在，任务只等待处理器的分配。
调度程序决定接下来执行哪个准备好的任务。

--等待:任务不能继续执行，因为它必须等待至少一个事件(见章节7)。

--挂起:任务为被动状态，可被激活。

![20250114091244](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114091244.png)

![20250114092626](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114092626.png)

只有当任务自己终止(“self-terminate")时，才有可能终止任务。这个限制降低了操作系统的复杂性。不提供从挂起状态到等待状态的直接转换。这种转换是多余的，会增加调度器的复杂性。

#### 4.2.3 基本任务
基本任务的状态模型几乎与扩展任务的状态模型相同。唯一的例外是基本任务没有等待状态。基本任务由以下任务状态组成:

--运行:在运行状态下，任务被分配给 CPU，使其指令可以执行。在任何时间点，只有一个任务处于该状态，而其他所有状态可以被多个任务同时采用。

--就绪:转换到运行状态的所有功能先决条件都已经存在，任务只等待处理器的分配调度程序决定接下来执行哪个准备好的任务。

--挂起:任务为被动状态，可被激活。

![20250114100316](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114100316.png)

![20250114100333](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114100333.png)

#### 4.2.4 任务类型的比较

基本任务没有等待状态，因此只包含任务开始和结束的同步点。具有内部同步点的application parts(**每一个函数是一个parts**)应由多个基本任务实现。基本任务的一个优点是它们对运行时上下文(RAM)的需求适中。

扩展任务的一个优点是，无论哪个同步请求是活动的，它们都可以在单个任务中处理一致的作业。当需要进一步处理的当前信息缺失时，扩展任务将切换到等待状态。当相应的事件发出接收或更新所需数据或事件的信号时，它将退出此状态。扩展任务还包含比基本任务更多的同步点。

### 4.3 激活一个任务
#### 4.3.1 General
任务激活通过操作系统服务 ActivatTask或chainTask进行。激活后，任务就可以从第一条语句开始执行了。

操作系统在启动任务时不支持类c参数传递。这些参数应该通过消息通信(参见第10条)或全局变量传递。

#### 4.3.2 任务激活的多个请求
根据一致性类的不同，基本任务可以被激活一次或多次。"任务激活的多个请求"意味着操作系统接收并记录一个已激活的基本任务的并行激活。(**判断任务会不会被多次激活就看是否会计数**)
并行多个请求的数量在系统生成期间在一个基本任务特定属性中定义。如果未达到多个请求的最大数量，则请求将进入队列。基本任务激活的请求按激活顺序按优先级排队。

## 4.4 任务切换机制

与传统的顺序编程不同，多任务处理原则上允许操作系统并发地执行各种任务。因此，需要明确调度策略(参见 4.6)。

决定启动哪个任务和触发所有必要的操作系统内部活动的实体被称为“调度程序”。根据所述的调度策略，只要有可能进行任务切换，就激活所述调度程序。调度器可以被看作是一种可以被任务占用和释放的资源。因此，任务可以保留调度程序，以避免任务切换，直到它被释放(见 8.4)。

## 4.5 任务优先级
调度程序根据任务优先级来决定哪个任务是下一个要转移到运行态的就绪任务。

0被定义为任务的最低优先级。因此，数字越大，优先级越高。

为提高效率，不支持动态优先级管理。因此，任务的优先级是静态定义的，即用户在运行时不能更改任务的优先级。但是，在特定情况下，OS可以处理具有定义的更高优先级的任务(**天花板级**)(参见 8.6)。

一致性类BCC2和ECC支持具有相同优先级的任务(参见3.2)。

具有相同优先级的任务根据其激活顺序启动,处于等待状态的扩展任务不会阻塞具有相同优先级的后续任务的启动。

被抢占的任务被认为是其当前优先级的就绪列表中的第一个(最早的)任务。
从等待状态释放的任务将被视为其优先级就绪队列中的最后一个(最新的)任务。

图6显示了使用每个优先级级别的队列实现调度程序的示例。几个优先级不同的任务处于就绪状态;即三个优先级为3的任务，一个优先级为2，一个优先级为1，再加上两个优先级为0的任务。根据请求的顺序，等待时间最长的任务显示在每个队列的底部。处理器刚刚处理并终止了一个任务。调度程序选择要处理的下一个任务(优先级3，第一个队列)。在处理优先级2的任务之前，所有高优先级的任务都必须处于运行就绪状态，即启动，然后由于终止或过渡到等待状态而从队列中移除。

![20250114102934](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114102934.png)

以下基本步骤是确定下一个要处理的任务所必需的:
--调度器搜索所有处于就绪/运行状态的任务。
--从处于就绪/运行状态的任务集中，调度程序确定具有最高优先级的任务集。
--在处于就绪/运行状态且优先级最高的任务集中，调度程序找到最早的任务。

## 4.6 调度策略
### 4.6.1 全抢占式调度 Full Preemptive scheduling

完全抢占式调度是指当前正在运行的任务可以根据操作系统预先设定的触发条件,在任何指令下重新调度。一旦高优先级的任务就绪，完全抢占式调度就会将正在运行的任务置于就绪状态。任务上下文被保存，以便被抢占的任务可以在它被抢占的位置继续执行。

完全抢占式调度的延迟时间与低优先级任务的运行时间无关。某些限制与节省上下文所需的(RAM)内存空间的增加，以及任务之间同步所需特性的复杂性的增强有关。由于理论上每个任务都可以在任何位置重新调度，因此与其他任务联合使用的数据访问需要同步。

在图7中，低优先级任务T2不会延迟高优先级任务T1的调度。

![20250114103819](https://cdn.jsdelivr.net/gh/xiongGithub1/picGoUpload/image/20250114103819.png)

在完全抢占系统的情况下，用户应该不断地期望正在运行的任务被抢占。如果一个任务片段不能被抢占，可以通过系统服务 GetResource 暂时阻塞调度程序来实现。

综上所述，在以下所有情况下都会执行重调度(**调度点**):

--成功终止任务(系统服务终止任务，参见13.3.3.2);(**t1执行完后要执行t2就用这个terminate**)

--通过显式激活后继任务成功终止任务(系统服务 ChainTask，见 13.3.3.3);（**t1任务执行完后还要执行一次t1就用这个接t2也行**）

--在任务级别激活任务(如系统服务激活任务，参见 13.3.3.1，消息通知机制，Alarm过期:如果定义了任务激活，参见 9.3);

--显式 wait 调用，此时系统会发生向 Waiting 状态的转换(仅扩展任务、系统服务)WaitEvent,见13.6.3.4;

--设置事件为任务级别的等待任务(如系统服务 SetEvent，参见 13.6.3.1，消息通知机制，Alarm 过期;如果事件设置已定义，请参见 9.3);

--任务级资源释放(系统服务Release Resource，参见13.5.3.2);

--从中断级返回到任务级。

在中断服务例程中，不执行重调度(参见图 2)。(因为 ISR 不属于可调度上下文，一旦跳出去就回不来了)